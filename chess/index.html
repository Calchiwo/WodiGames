<!-- README
Chess WodiGame

To run locally:
1. Save the four files: index.html, styles.css, chess.js, ai.js in a directory.
2. Open index.html in a modern browser.

No server needed.
-->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chess WodiGame</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <header>
    <h1>Chess WodiGame</h1>
    <nav>
      <button id="new-game">New Game</button>
      <select id="play-as">
        <option value="w">Play as White</option>
        <option value="b">Play as Black</option>
      </select>
      <select id="ai-difficulty">
        <option value="1">Easy (Depth 1)</option>
        <option value="2">Medium (Depth 2)</option>
        <option value="3">Hard (Depth 3)</option>
        <option value="4">Expert (Depth 4)</option>
        <option value="5">Master (Depth 5)</option>
      </select>
      <button id="flip-board">Flip Board</button>
      <select id="theme">
        <option value="classic">Classic Theme</option>
        <option value="wood">Wood Theme</option>
      </select>
      <select id="piece-style">
        <option value="unicode">Unicode</option>
        <option value="letter">Letter</option>
      </select>
      <button id="sounds-toggle">Sounds On</button>
      <button id="dark-mode-toggle">Dark Mode</button>
      <button id="hint">Hint</button>
      <button id="undo">Undo</button>
      <button id="redo">Redo</button>
      <button id="export-pgn">Export PGN</button>
      <button id="import-pgn">Import PGN</button>
      <input id="fen-input" type="text" placeholder="Load FEN">
      <button id="load-fen">Load FEN</button>
      <button id="clock-toggle">Clock Off</button>
      <span id="white-time">10:00</span>
      <span id="black-time">10:00</span>
      <button id="perft">Run Perft 4</button>
    </nav>
  </header>
  <main>
    <div class="side-panel left">
      <div class="captured white-captured"></div> <!-- Captured white pieces -->
    </div>
    <div class="board-container">
      <div class="board"></div>
    </div>
    <div class="side-panel right">
      <div class="captured black-captured"></div> <!-- Captured black pieces -->
      <div class="move-list"></div>
    </div>
  </main>
  <div id="promotion-modal" class="modal">
    <div class="modal-content">
      <button data-piece="Q">Queen</button>
      <button data-piece="R">Rook</button>
      <button data-piece="B">Bishop</button>
      <button data-piece="N">Knight</button>
    </div>
  </div>
  <script type="module">
    import { Chess } from './chess.js';
    import * as AI from './ai.js';

    const game = new Chess();
    const boardElem = document.querySelector('.board');
    const whiteCapturedElem = document.querySelector('.white-captured');
    const blackCapturedElem = document.querySelector('.black-captured');
    const moveListElem = document.querySelector('.move-list');
    let selectedSquare = -1;
    let legalMoves = [];
    let isFlipped = false;
    let playerSide = 'w';
    let aiSide = 'b';
    let aiDifficulty = 3;
    let theme = localStorage.getItem('theme') || 'classic';
    let pieceStyle = localStorage.getItem('piece-style') || 'unicode';
    let soundsOn = localStorage.getItem('sounds') !== 'off';
    let darkMode = localStorage.getItem('dark-mode') === 'true';
    let clockOn = false;
    let whiteTime = 600;
    let blackTime = 600;
    let clockInterval;
    let redoStack = [];

    const pieceMaps = {
      unicode: {
        1: '♙', 2: '♘', 3: '♗', 4: '♖', 5: '♕', 6: '♔',
        7: '♟', 8: '♞', 9: '♝', 10: '♜', 11: '♛', 12: '♚'
      },
      letter: {
        1: 'P', 2: 'N', 3: 'B', 4: 'R', 5: 'Q', 6: 'K',
        7: 'p', 8: 'n', 9: 'b', 10: 'r', 11: 'q', 12: 'k'
      }
    };

    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    function playSound(freq, duration) {
      if (!soundsOn) return;
      const osc = audioCtx.createOscillator();
      osc.type = 'sine';
      osc.frequency.value = freq;
      osc.connect(audioCtx.destination);
      osc.start();
      setTimeout(() => osc.stop(), duration);
    }

    function soundMove() { playSound(440, 100); }
    function soundCapture() { playSound(330, 100); }
    function soundCheck() { playSound(220, 200); }

    // Create board squares
    for (let rank = 7; rank >= 0; rank--) {
      for (let file = 0; file < 8; file++) {
        const square = document.createElement('div');
        square.classList.add('square');
        square.dataset.index = rank * 8 + file;
        square.tabIndex = 0;
        square.setAttribute('role', 'gridcell');
        const isLight = (rank + file) % 2 === 0;
        square.classList.add(isLight ? 'light' : 'dark');
        boardElem.appendChild(square);
      }
    }
    const squares = boardElem.querySelectorAll('.square');

    function fileToAlg(file) { return 'abcdefgh'[file]; }
    function indexToAlg(index) {
      const file = 'abcdefgh'[index % 8];
      const rank = Math.floor(index / 8) + 1;
      return file + rank;
    }
    function algToIndex(alg) {
      const file = 'abcdefgh'.indexOf(alg[0]);
      const rank = parseInt(alg[1]) - 1;
      return rank * 8 + file;
    }

    function renderBoard() {
      squares.forEach(s => {
        s.classList.remove('selected', 'legal', 'last-from', 'last-to', 'check', 'hint-from', 'hint-to');
      });
      for (let i = 0; i < 64; i++) {
        const piece = game.board[i];
        const html = piece ? `<span class="piece">${pieceMaps[pieceStyle][piece]}</span>` : '';
        const sqIndex = isFlipped ? 63 - i : i;
        squares[sqIndex].innerHTML = html;
      }
      if (selectedSquare !== -1) {
        const sqIndex = isFlipped ? 63 - selectedSquare : selectedSquare;
        squares[sqIndex].classList.add('selected');
        legalMoves.forEach(m => {
          const toIndex = isFlipped ? 63 - m.to : m.to;
          squares[toIndex].classList.add('legal');
        });
      }
      if (game.history.length) {
        const last = game.history[game.history.length - 1];
        const fromIndex = isFlipped ? 63 - last.from : last.from;
        const toIndex = isFlipped ? 63 - last.to : last.to;
        squares[fromIndex].classList.add('last-from');
        squares[toIndex].classList.add('last-to');
      }
      if (game.isCheck()) {
        const kingSq = game.getKingSquare(game.turn);
        const kingIndex = isFlipped ? 63 - kingSq : kingSq;
        squares[kingIndex].classList.add('check');
      }
      renderCaptured();
      renderMoveList();
      checkGameOver();
      updateARIA();
    }

    function updateARIA() {
      squares.forEach(s => {
        const idx = parseInt(s.dataset.index);
        let label = indexToAlg(idx);
        const piece = game.board[idx];
        if (piece) {
          const color = game.getColor(piece) === 'w' ? 'white' : 'black';
          const type = ['', 'pawn', 'knight', 'bishop', 'rook', 'queen', 'king'][game.getType(piece)];
          label += ` ${color} ${type}`;
        }
        s.setAttribute('aria-label', label);
      });
    }

    function renderCaptured() {
      const sortedWhite = [...game.capturedWhite].sort((a, b) => AI.materialValues[b] - AI.materialValues[a]);
      const sortedBlack = [...game.capturedBlack].sort((a, b) => AI.materialValues[b] - AI.materialValues[a]);
      whiteCapturedElem.innerHTML = sortedWhite.map(p => `<span class="piece">${pieceMaps[pieceStyle][p]}</span>`).join('');
      blackCapturedElem.innerHTML = sortedBlack.map(p => `<span class="piece">${pieceMaps[pieceStyle][p]}</span>`).join('');
    }

    function renderMoveList() {
      moveListElem.innerHTML = '';
      game.history.forEach((move, idx) => {
        if (idx % 2 === 0) {
          const div = document.createElement('div');
          div.textContent = `${Math.floor(idx / 2 + 1)}. ${move.san}`;
          div.dataset.ply = idx;
          div.onclick = () => jumpToMove(idx);
          div.tabIndex = 0;
          moveListElem.appendChild(div);
        } else {
          moveListElem.lastChild.textContent += ` ${move.san}`;
        }
      });
    }

    function jumpToMove(ply) {
      while (game.history.length > ply + 1) {
        redoStack.push(game.history[game.history.length - 1]);
        game.undoMove();
      }
      renderBoard();
    }

    function checkGameOver() {
      if (game.isCheckmate()) {
        alert(`${game.turn === 'w' ? 'Black' : 'White'} wins by checkmate!`);
      } else if (game.isStalemate()) {
        alert('Stalemate!');
      } else if (game.isDraw()) {
        alert('Draw!');
      }
    }

    function onSquareClick(e) {
      let target = e.target;
      if (target.classList.contains('piece')) target = target.parentNode;
      const index = parseInt(target.dataset.index);
      if (selectedSquare === -1) {
        if (game.board[index] && game.getColor(game.board[index]) === game.turn && game.turn === playerSide) {
          selectedSquare = index;
          legalMoves = game.getLegalMoves(index);
        }
      } else {
        const move = legalMoves.find(m => m.to === index);
        if (move) {
          if (move.promotion) {
            showPromotion(move.from, move.to);
          } else {
            performMove(move);
          }
        } else if (game.board[index] && game.getColor(game.board[index]) === game.turn) {
          selectedSquare = index;
          legalMoves = game.getLegalMoves(index);
        } else {
          selectedSquare = -1;
          legalMoves = [];
        }
      }
      renderBoard();
    }

    boardElem.addEventListener('click', onSquareClick);

    // Drag and drop
    squares.forEach(sq => {
      sq.draggable = true;
      sq.addEventListener('dragstart', e => {
        const index = parseInt(sq.dataset.index);
        if (game.board[index] && game.getColor(game.board[index]) === game.turn && game.turn === playerSide) {
          selectedSquare = index;
          legalMoves = game.getLegalMoves(index);
          renderBoard();
          e.dataTransfer.setData('text/plain', index);
        } else {
          e.preventDefault();
        }
      });
      sq.addEventListener('dragover', e => e.preventDefault());
      sq.addEventListener('drop', e => {
        e.preventDefault();
        const from = parseInt(e.dataTransfer.getData('text/plain'));
        let toElem = e.target;
        if (toElem.classList.contains('piece')) toElem = toElem.parentNode;
        const to = parseInt(toElem.dataset.index);
        const move = legalMoves.find(m => m.from === from && m.to === to);
        if (move) {
          if (move.promotion) {
            showPromotion(from, to);
          } else {
            performMove(move);
          }
        }
        selectedSquare = -1;
        legalMoves = [];
        renderBoard();
      });
    });

    // Keyboard navigation
    let focusedSq = 0;
    document.addEventListener('keydown', e => {
      switch (e.key) {
        case 'ArrowLeft': focusedSq = Math.max(0, focusedSq % 8 === 0 ? focusedSq : focusedSq - 1); break;
        case 'ArrowRight': focusedSq = Math.min(63, (focusedSq + 1) % 8 === 0 ? focusedSq : focusedSq + 1); break;
        case 'ArrowUp': focusedSq = Math.min(63, focusedSq + 8); break;
        case 'ArrowDown': focusedSq = Math.max(0, focusedSq - 8); break;
        case 'Enter': onSquareClick({ target: squares[focusedSq] }); break;
      }
      squares.forEach(s => s.classList.remove('focus'));
      if (e.key.startsWith('Arrow')) {
        squares[focusedSq].classList.add('focus');
        squares[focusedSq].focus();
      }
    });

    function showPromotion(from, to) {
      const modal = document.getElementById('promotion-modal');
      modal.style.display = 'flex';
      const buttons = modal.querySelectorAll('button');
      buttons.forEach(btn => {
        btn.onclick = () => {
          let prom = btn.dataset.piece;
          prom = game.turn === 'w' ? prom : prom.toLowerCase();
          const move = { from, to, promotion: prom };
          performMove(move);
          modal.style.display = 'none';
        };
      });
    }

    function performMove(move) {
      const captured = game.board[move.to];
      redoStack = [];
      game.makeMove(move);
      renderBoard();
      if (captured) soundCapture();
      else soundMove();
      if (game.isCheck()) soundCheck();
      if (game.turn === aiSide) {
        setTimeout(aiMove, 500); // delay for realism
      }
    }

    function aiMove() {
      const move = AI.getBestMove(game, aiDifficulty);
      if (move) performMove(move);
    }

    // Button events
    document.getElementById('new-game').onclick = () => {
      game.loadFen('rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1');
      redoStack = [];
      whiteTime = 600;
      blackTime = 600;
      updateClockDisplays();
      renderBoard();
      if (game.turn === aiSide) aiMove();
    };

    document.getElementById('play-as').onchange = e => {
      playerSide = e.target.value;
      aiSide = playerSide === 'w' ? 'b' : 'w';
      if (game.turn === aiSide) aiMove();
    };

    document.getElementById('ai-difficulty').onchange = e => {
      aiDifficulty = parseInt(e.target.value);
    };

    document.getElementById('flip-board').onclick = () => {
      isFlipped = !isFlipped;
      boardElem.classList.toggle('flipped');
      renderBoard();
    };

    document.getElementById('theme').onchange = e => {
      theme = e.target.value;
      localStorage.setItem('theme', theme);
      document.body.className = theme;
      if (darkMode) document.body.classList.add('dark-mode');
    };

    document.getElementById('piece-style').onchange = e => {
      pieceStyle = e.target.value;
      localStorage.setItem('piece-style', pieceStyle);
      renderBoard();
    };

    document.getElementById('sounds-toggle').onclick = () => {
      soundsOn = !soundsOn;
      localStorage.setItem('sounds', soundsOn ? 'on' : 'off');
      this.textContent = `Sounds ${soundsOn ? 'On' : 'Off'}`;
    };

    document.getElementById('dark-mode-toggle').onclick = () => {
      darkMode = !darkMode;
      document.body.classList.toggle('dark-mode');
      localStorage.setItem('dark-mode', darkMode);
      this.textContent = `${darkMode ? 'Light' : 'Dark'} Mode`;
    };

    document.getElementById('hint').onclick = () => {
      const move = AI.getBestMove(game, aiDifficulty);
      if (move) {
        const fromIndex = isFlipped ? 63 - move.from : move.from;
        const toIndex = isFlipped ? 63 - move.to : move.to;
        squares[fromIndex].classList.add('hint-from');
        squares[toIndex].classList.add('hint-to');
        setTimeout(() => {
          squares.forEach(s => s.classList.remove('hint-from', 'hint-to'));
        }, 3000);
      }
    };

    document.getElementById('undo').onclick = () => {
      if (game.history.length) {
        redoStack.push(game.history[game.history.length - 1]);
        game.undoMove();
        if (game.turn === playerSide && game.history.length && game.history[game.history.length - 1].turnBefore !== playerSide) {
          redoStack.push(game.history[game.history.length - 1]);
          game.undoMove();
        }
        renderBoard();
      }
    };

    document.getElementById('redo').onclick = () => {
      if (redoStack.length) {
        game.makeMove(redoStack.pop(), true);
        if (redoStack.length && game.turn === aiSide) {
          game.makeMove(redoStack.pop(), true);
        }
        renderBoard();
      }
    };

    document.getElementById('export-pgn').onclick = () => {
      const pgn = game.generatePGN();
      prompt('PGN:', pgn);
    };

    document.getElementById('import-pgn').onclick = () => {
      const pgn = prompt('Paste PGN:');
      if (pgn) {
        game.loadPGN(pgn);
        renderBoard();
      }
    };

    document.getElementById('load-fen').onclick = () => {
      const fen = document.getElementById('fen-input').value;
      if (fen) {
        game.loadFen(fen);
        renderBoard();
      }
    };

    document.getElementById('clock-toggle').onclick = () => {
      clockOn = !clockOn;
      this.textContent = `Clock ${clockOn ? 'On' : 'Off'}`;
      if (clockOn) startClock();
      else stopClock();
    };

    function startClock() {
      stopClock();
      clockInterval = setInterval(() => {
        if (game.turn === 'w') whiteTime = Math.max(0, whiteTime - 1);
        else blackTime = Math.max(0, blackTime - 1);
        updateClockDisplays();
        if (whiteTime === 0) alert('Black wins on time!');
        if (blackTime === 0) alert('White wins on time!');
      }, 1000);
    }

    function stopClock() {
      if (clockInterval) clearInterval(clockInterval);
    }

    function updateClockDisplays() {
      document.getElementById('white-time').textContent = formatTime(whiteTime);
      document.getElementById('black-time').textContent = formatTime(blackTime);
    }

    function formatTime(s) {
      const m = Math.floor(s / 60);
      s = s % 60;
      return `${m}:${s < 10 ? '0' : ''}${s}`;
    }

    document.getElementById('perft').onclick = () => {
      console.log('Perft 4:', game.perft(4));
    };

    // Init
    document.body.classList.add(theme);
    if (darkMode) document.body.classList.add('dark-mode');
    document.getElementById('sounds-toggle').textContent = `Sounds ${soundsOn ? 'On' : 'Off'}`;
    document.getElementById('dark-mode-toggle').textContent = `${darkMode ? 'Light' : 'Dark'} Mode`;
    document.getElementById('theme').value = theme;
    document.getElementById('piece-style').value = pieceStyle;
    document.getElementById('play-as').value = playerSide;
    document.getElementById('ai-difficulty').value = aiDifficulty;
    updateClockDisplays();
    renderBoard();
    if (game.turn === aiSide) aiMove();
  </script>
</body>
</html>
